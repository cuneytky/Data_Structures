 â— What is a Data Structure / Algorithm
 â— Big O notation

 ****************************************************************
What is a Data Structure ?
â— Data structure is a particular way of storing and organizing data in a computer so that it can be used efficiently.
â— General data structure types include arrays, files, linked lists, stacks, queues, trees, graphs and so on.
â— Depending on the organization of the elements, data structures are classified into two types:
    1) Linear data structures: Elements are accessed in a sequential order but it
        is not compulsory to store all elements sequentially (say, Linked Lists).
        Examples: Linked Lists, Stacks and Queues.
    2) Non â€“ linear data structures: Elements of this data structure are
        stored/accessed in a non-linear order. Examples: Trees and graphs

--------------------

 ==> How do we compare algorithms?
Ideal solution : Expressing running time of an algorithm as a function of input size.
f(n) where the input size is n.
-This type of comparison is independent of machine time, programming style, etc
---------------
 *  asymptotic analysis is a method of describing limiting behavior

 *  In any piece of code; you deal with two types of complexities:
1. Time complexity: Number of steps taken by the algorithm, measured with respect to n (input data to be processed), the size of the input.
2. Space complexity: The amount of space required by the algorithm to execute, measured with respect to n (input data to be processed)

---------------
 => What is Big O notation?
â— Big O notation, also called Landau's symbol, is a symbolism used in complexity theory, computer science, and mathematics to describe the asymptotic behavior of functions.
â— Basically, it tells you how fast a function grows or declines. In other words:Rate of Growth.
â— The â€™Big-Oâ€™ is the language and metric we use to describe the efficiency of algorithms.
â— Big-O is a Big Picture approach;
The â€™Big-Oâ€™ notation allows us to ignore constant factors and lower-order terms and focus on the main components of a function that affect its growth.
Rule 1: Always worst Case
Rule 2: Remove Constants
Rule 3 : If f (n) is a polynomial of degree d, that is,
Rule 4 : Different inputs should have different variables: O(n + m) : â€™+â€™ for steps in order
         A and B arrays nested would be: O(n * m) : â€˜*â€™ for nested steps

---------------

How Do I Calculate the Complexity of Code Blocks?

* What Can Cause Time in a Code Piece? ==> Take a constant time â€œcâ€
â€¢ Assigning a value to a variable
â€¢ Following an object reference
â€¢ Performing an arithmetic operation (+, -, *, / )
â€¢ Comparing two numbers
â€¢ Accessing a single element of an array by index
â€¢ Calling a method
â€¢ Returning from a method

* What Causes Space Complexity?
Variables
Data Structures (additional)
Method Call
Allocations

- Loops        ==>  Total time= constant c x n= cn = O(n)
- Nested Loops ==>  Total time= c x n x n= cð‘›2 = O(ð‘›2 )
- Consecutive Statements ==>  Total time=ð‘0 + ð‘1ð‘› + ð‘2ð‘›2 = O(ð‘›2 )
- If then Statements     ==>  Total = ð‘0 + (ð‘1+ ð‘2)ð‘™ð‘’ð‘›ð‘”ð‘¡â„Ž = O(length)
- Logarithmic complexity ==> Total time=O(log ð‘›)
- what if I have different data sets? ==>  Total = O(n*m) (rule 4)

============
??? Interview Questions --> big O ?
          Omega   Theta   Big O
Best Case <---------------------> Worst Case

*******************************************************************
Arrays
    â€¢ An array is the basic mechanism for storing a collection of identically typed entities.
    â€¢ Arrays use static memory allocation.
    â€¢ Arrays can also be multi-dimensional
â— Advantages:
    âˆ’ Simple and easy to use
    âˆ’ Faster access to the elements (constant access)
â— Disadvantages:
    âˆ’Preallocates all needed memory up front and wastes memory space for indices in the array that are empty.
    âˆ’Fixed size: The size of the array is static (specify the array size before using it).
    âˆ’One block allocation: To allocate the array itself at the beginning, sometimes it may not be possible to
        get the memory for the complete array (if the array size is big).
    âˆ’Complex position-based insertion: To insert an element at a given position, we may need to shift the
        existing elements

Dynamic Arrays
â— Dynamic arrays are resizable, growable arrays.
â— How can we create dynamic arrays?
â— There two implementations of Dynamic Arrays in Java:
    - Vector class : Size is increased by %100 if full. Synchronized (Only a single thread can access in multi-threaded environment )
    - ArrayList class: Size is increased by % 50 if fuIl. If you need multithreads access to data you should prefer ArrayList class

Implementation of Dynamic Arrays in Java
â— Vector and ArrayList are under java.util package
â— They can hold objects so, for primitive types use wrapper class.

ArrayList and Vector Performance
â— add()     â€“ O(1)
â— add(index, element) â€“ O(n)
â— get()     â€“ O(1)
â— remove()  â€“ O(n)
â— indexOf() â€“ O(n)
â— contains() â€“ implementation is based on indexOf(). So it will also run in O(n) time.




Arrays - Key Takeaways
â— Simplest Data Structure
â— Static (Arrays) vs dynamic (ArrayList & Vector)
â— Arrays are great if you know how many items youâ€™ll store.
Runtime Complexities:
    Lookup by Index O(1)
    Lookup by Value O(n)
    Insert O(n)
    Delete O(n)

    *******************************************************************
QUESTÄ°ONS-ANSWERS:
1-ilk for n, ikinci for n, n+n=2n, 2 sabÄ±t alÄ±nmaz sonuc --> O(n)
2- nested loop, nxn = O(n2)
3- operation sabÄ±t alÄ±nmaz, bxc = b sonuÃ§ --> O(b)
4- 100000xbxa-> constant deÄŸer alÄ±nmaz(data lar sabÄ±t alÄ±nmaz) sonuc --> O(axb)

*******************************************************************

Big O Cheat Sheet
Big Os :
O(1) Constant        â€“ no loops
O(log N) Logarithmic â€“ usually searching algorithms have log n if they are sorted (Binary Search)
O(n) Linear           â€“ for loops, while loops through n items
O(n log(n)) Log Linear â€“ usually sorting operations
O(n^2) Quadratic        â€“ every element in a collection needs to be compared to ever other element. Two nested loops
O(2^n) Exponential    â€“ recursive algorithms that solves a problem of size N
O(n!) Factorial      â€“ you are adding a loop for every element
Iterating through half a collection is still O(n)
Two separate collections: O(a * b)
-----
What Can Cause Time in a Code?
Operations (+, -, *, /)
Comparisons (<, >, ==)
Looping (for, while)
Outside Function call (function())
-----
What Causes Space Complexity?
Variables
Data Structures
Function Call
Allocations
-----
Rule Book
Rule 1: Always worst Case
Rule 2: Remove Constants (c1+c2+ 2n2)
Rule 3: Different inputs should have different variables: O(a + b)
        A and B arrays nested would be: O(a * b)
        + for steps in order
        * for nested steps
Rule 4: Drop Non-dominant terms
*******************************************************************
